name: Deploy API-Gateway

on:
  push:
    branches: [main, stage, integration, develop]
    paths:
      - 'apps/micro-services/api-gateway/**'
      - 'libs/**'
      - '!libs/ir-plugin/**'
      - '.github/workflows/api-gateway.yml'
      - 'package.json'
      - 'Dockerfile.deps'
      - '!**/*.md'
      - '!.*ignore'

  pull_request:
    branches: [main, stage, integration, develop]
    paths:
      - 'apps/micro-services/api-gateway/**'
      - 'libs/**'
      - '!libs/ir-plugin/**'
      - '.github/workflows/api-gateway.yml'
      - 'package.json'
      - 'Dockerfile.deps'
      - '!**/*.md'
      - '!.*ignore'

  workflow_dispatch:

env:
  APP_NAME: ir-api-gateway
  APP_SUB_DIR: ./apps/micro-services/api-gateway
  TARGET_BRANCH_NAME: ${{ github.base_ref || github.ref_name }}
  IMAGE_VERSION: ${{ github.sha }}
  DOCKER_REGISTRY: ghcr.io/theinfinitereality
  AWS_ACCESS_KEY_ID: ${{ secrets.SREDO_IAC_IAM_ACCESS_KEY_MAIN }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.SREDO_IAC_IAM_SECRET_KEY_MAIN }}
  GH_ACTOR: ${{ github.actor }}
  CD_TOKEN: ${{ secrets.CD_TOKEN }}
  AWS_REGION: us-east-2

jobs:
  set_environment:
    outputs:
      my_env: ${{ steps.setenv.outputs.my_env }}
    runs-on: ubuntu-latest
    steps:
    - id: setenv
      run: |
          if [ "${{ env.TARGET_BRANCH_NAME }}" = "main" ]; then
            echo "my_env=production" >> $GITHUB_OUTPUT
          elif [ "${{ env.TARGET_BRANCH_NAME }}" = "stage" ]; then
            echo "my_env=stage" >> $GITHUB_OUTPUT
          elif [ "${{ env.TARGET_BRANCH_NAME }}" = "integration" ]; then
            echo "my_env=integration" >> $GITHUB_OUTPUT
          else
            echo "my_env=development" >> $GITHUB_OUTPUT
          fi

  test-build-image:
    name: Test Docker Build
    if: github.event_name == 'pull_request'
    needs: set_environment
    environment:
      name: ${{ needs.set_environment.outputs.my_env }}
    env:
      ENV: ${{ needs.set_environment.outputs.my_env }}
      AWS_ENV_ROLE: ${{ secrets.AWS_ROLE_ARN }}
      AWS_INSTANCE_SG_ID: ${{ secrets.EC2_SEC_GROUP }}

    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.APP_SUB_DIR }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Public IP
        id: ip
        uses: haythem/public-ip@v1.3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          role-to-assume: ${{ env.AWS_ENV_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-skip-session-tagging: true

      - name: whitelist runner ip address
        run: |
          aws ec2 authorize-security-group-ingress \
            --group-id ${{ env.AWS_INSTANCE_SG_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32

      - name: Test SSH into Ec2
        uses: appleboy/ssh-action@v1.0.0
        # continue-on-error: true
        with:
          host: ${{ secrets.EC2_HOST }}
          key: ${{ secrets.EC2_KEY }}
          username: ubuntu
          script: |
            whoami
            touch test.txt

      - name: revoke runner ip address
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
            --group-id ${{ env.AWS_INSTANCE_SG_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32

      - name: Make envfile
        uses: SpicyPizza/create-envfile@v2.0
        with:
          # envars pre-fixed with 'envkey'
          envkey_PORT: 3000
          envkey_ENVIRONMENT: ${{ env.ENV }}
          envkey_NATS_SERVERS: ${{ secrets.NATS_SERVER }}
          envkey_REDIS_HOST: ${{ secrets.REDIS_HOST }}
          envkey_REDIS_PORT: 6379
          envkey_REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          envkey_REDIS_NAMESPACE: ${{ env.APP_NAME }}
          envkey_REDIS_TTL: 10
          # envkey_FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

          # additional action inputs
          directory: ${{ env.APP_SUB_DIR }}
          file_name: .env.${{ env.ENV }}
          fail_on_empty: true
          sort_keys: false

      - name: Build Test Image
        id: build-image
        uses: docker/build-push-action@v4
        with:
          context: "."
          file: "${{ env.APP_SUB_DIR }}/Dockerfile"
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-${{ env.ENV }}:test
          push: false
          build-args: |
            ENVIRONMENT=${{ env.ENV }}

  build-and-push-image:
    name: Docker Build and Upload
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: set_environment
    environment:
      name: ${{ needs.set_environment.outputs.my_env }}
    env:
      ENV: ${{ needs.set_environment.outputs.my_env }}
      AWS_ENV_ROLE: ${{ secrets.AWS_ROLE_ARN }}
      AWS_INSTANCE_SG_ID: ${{ secrets.EC2_SEC_GROUP }}
      FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
      NATS_SERVER: ${{ secrets.NATS_SERVER }}

    defaults:
      run:
        working-directory: ${{ env.APP_SUB_DIR }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.GH_ACTOR }}
          password: ${{ env.CD_TOKEN }}

      - name: Make envfile
        uses: SpicyPizza/create-envfile@v2.0
        with:
          # envars pre-fixed with 'envkey'
          envkey_PORT: 3000
          envkey_ENVIRONMENT: ${{ env.ENV }}
          envkey_NATS_SERVERS: ${{ secrets.NATS_SERVER }}
          envkey_REDIS_HOST: ${{ secrets.REDIS_HOST }}
          envkey_REDIS_PORT: 6379
          envkey_REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          envkey_REDIS_NAMESPACE: ${{ env.APP_NAME }}
          envkey_REDIS_TTL: 10
          # envkey_FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}

          # additional action inputs
          directory: ${{ env.APP_SUB_DIR }}
          file_name: .env.${{ env.ENV }}
          fail_on_empty: true
          sort_keys: false

      - name: Build and Push image
        id: push-image
        uses: docker/build-push-action@v4
        with:
          cache-from: type=gha
          cache-to: type=gha,mode=max
          context: "."
          file: "${{ env.APP_SUB_DIR }}/Dockerfile"
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-${{ env.ENV }}:latest
          push: true
          build-args: |
            ENVIRONMENT=${{ env.ENV }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          role-to-assume: ${{ env.AWS_ENV_ROLE }}
          aws-region: ${{ env.AWS_REGION }}
          role-skip-session-tagging: true

      - name: Public IP
        id: ip
        uses: haythem/public-ip@v1.3

      - name: whitelist runner ip address
        run: |
          aws ec2 authorize-security-group-ingress \
            --group-id ${{ env.AWS_INSTANCE_SG_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32

      - name: Deploy Docker Image to Ec2
        uses: appleboy/ssh-action@v1.0.0
        # continue-on-error: true
        env:
          DOCKER_REG_REPO_NAME: ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-${{ env.ENV }}
        with:
          host: ${{ secrets.EC2_HOST }}
          key: ${{ secrets.EC2_KEY }}
          username: ubuntu
          envs: APP_NAME, DOCKER_REG_REPO_NAME, CD_TOKEN, GH_ACTOR
          script: |
            docker stop $APP_NAME || true
            docker container rm $APP_NAME --force || true
            docker network create nats-cluster || true
            echo $CD_TOKEN | docker login ghcr.io -u $GH_ACTOR --password-stdin
            echo "Pulling $DOCKER_REG_REPO_NAME:latest"
            docker pull $DOCKER_REG_REPO_NAME:latest
            docker run -d \
              -p 3000:3000 \
              -w /app \
              --name $APP_NAME \
              --restart always \
              --network=nats-cluster \
              "$DOCKER_REG_REPO_NAME:latest"
            docker system prune --force --all || true

      - name: revoke runner ip address
        if: always()
        run: |
          aws ec2 revoke-security-group-ingress \
            --group-id ${{ env.AWS_INSTANCE_SG_ID }} \
            --protocol tcp \
            --port 22 \
            --cidr ${{ steps.ip.outputs.ipv4 }}/32
